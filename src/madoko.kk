/*---------------------------------------------------------------------------
  Copyright 2013 Microsoft Corporation.
 
  This is free software; you can redistribute it and/or modify it under the
  terms of the Apache License, Version 2.0. A copy of the License can be
  found in the file "license.txt" at the root of this distribution.
---------------------------------------------------------------------------*/

// Parse Madoko markdown text.
module madoko

import std/data/dict
import std/text/regex
import common
import options
import metadata
import block
import formatBlock
import inline
import formatInline
import definitions
import entity           // logEntities
import htmlFormatter    // for full
import texFormatter     // support legacy
import latexFormatter
import attributes       // expandKeys
import std/log

/* --------------------------------------
  Main library entry point 
---------------------------------------- */

// Takes source markdown input and returns formatted html
pub fun markdown( src : string, 
                          options : options = initialOptions0, 
                          fmt : formatter = FmtHtml 
                        ) : pure (string,options)
{
  if (options.xmp) then markdownXmp(src,options,fmt) else markdownNormal(src,options,fmt)
}

// Process only markdown between <xmp> tags 
fun markdownXmp( src : string, options : options = initialOptions0, fmt : formatter = FmtHtml ) : pure (string,options)
{
  val commented = "~begin htmlraw\n" ++ src.replaceAll(rxxmp,"\n~end htmlraw\n$2\n~begin htmlraw\n") ++ "\n~end htmlraw"
  markdownNormal(commented, options, fmt)
}
val rxxmp = regex(r"(<xmp\b" ++ tagContent ++ r">)([\s\S]*?)</xmp>")

pub fun normalizeSource( src : string ) : string {
  val srcnl = if (src.contains('\r')) then src.replaceAll(regex(r"\r\n?"),"\n") else src
  srcnl.replaceAll(regex(r"\t"), "    ") 
}

// Takes source markdown input and returns formatted html
fun markdownNormal( src0 : string, options0 : options = initialOptions0, fmt : formatter = FmtHtml ) : pure (string,options)
{  
  // first normalize the input: all tabs to 4 spaces.
  val (options1,src) = parseMeta(options0,fmt,src0.normalizeSource)
  val options = options1(metadata = options1.metadata.completeAuthorKeys)
  val xfull = options.full.maybe(True,id)     
  val logo  = if (xfull && options.logo) then "\n\n~Begin LogoMadoko\n&LogoMadoko;\n~End LogoMadoko\n" else "\n"
  
  if (options.verbose>=4) then {
    trace("metadata: " ++ fmt.showFormatter)
    options.metadata.foreach fn(md) {
      trace("  " ++ md.fst ++ ": " ++ md.snd.cutoff(80))
    }
    trace("parse blocks")
  }
  //val blocks = parseBlocks(src,options.citestyle,options.bench,options.pedantic )

  if (options.citeAll) then log("aux",r"\citation{*}")
  
  // parse definitions
  val icontext  = inlineContext(fmt,options.metadata.dict,
                                    options.math.dim,
                                    options.embedinfos, 
                                    options.citestyle.maybe(citeNumeric,id),
                                    options.sanitize,options.bench,options.verbose,
                                    options.math.mode.isStatic,
                                    options.highlight,options.starBold,options.sandbox,options.prettyAlign) 
  //if (options.verbose > 2) then trace("process definitions")
  val (fblocks,fcontext) 
    = parseBody(initialFormatContext(icontext,options.lineMap,
                                      options.headingBase,options.pedantic,fmt), 
                options.lineNo,
                src ++ logo,
                options.metadata, options.tocDepth,
                options.sectionBase,options.sectionMax)

  // parse inline elements
  if (options.verbose>=3) then trace("parse inline")
  val body = //(if (options.autoCount) then "<!-- generated by MarkedX -->\n" else "") ++ 
             formatBlocks(fcontext,fblocks)
  if (options.verbose>=3) then trace("generate output")

  // log links, labels, and entities
  if (fmt.isFmtHtml) then {
    fcontext.inlineContext.labels.list().foreach fn(elem) {
      val (name,label) = elem
      log("labels","{ \"name\": " ++ name.json ++ ", \"text\": " ++ label.labelText.json ++ ", \"caption\": " ++ label.labelCaption.json ++ " }" );
    }
    fcontext.inlineContext.links.list().foreach fn(elem) {
      val (name,link) = elem
      log("links","{ \"name\": " ++ name.json ++ ", \"href\": " ++ link.href.json ++ ", \"title\": " ++ link.title.json ++ " }" );
    }
    logEntities(); // log standard entities
    logMetadata(options.metadata);
  }

  // generate full html/tex if needed
  val res = if (xfull) 
             then (fmt.pick(fmtHtmlFull,fmtLatexFull))(body,options,fcontext.inlineContext.metadata)
             else body 
  // emit file references if necessary
  if (!xfull || !(fmt.isFmtHtml)) then fmtHtmlFull("",options,fcontext.inlineContext.metadata) else ""
  if (!xfull || !(fmt.isFmtTex))  then fmtLatexFull("",options,fcontext.inlineContext.metadata) else ""
  
  if (options.verbose>=3) then trace("done")
  (res,options)           
}

// Export initial options for JavaScript usage
pub val initialOptions0 = initialOptions();

pub fun initialOptions() {
  return Options();
}

pub fun traceRuleHist() {
  common/traceRuleHist()
}

fun logMetadata( mdata : metadata ) {
  mdata.foreach fn(kv) {
    val (key,value) = kv;
    if (!key.startsWith("~") && !key.startsWith(".") && !key.startsWith("#")) then {
      log("entities", "{\"name\":" ++ key.json ++ ",\"value\":" ++ value.json ++ "}")
    }
  }
}


// Create an ":inlineContext"
fun inlineContext( fmt : formatter, 
                               metadata : dict<string>,
                               mathinfos : dict<mathinfo>,
                               embedinfos : dict<embedinfo>,
                               citestyle : citestyle = citeAuto,
                               sanitize : bool = False,
                               bench: bool = False,
                               verbose : int = 0,
                               mathStatic : bool = False,
                               highlight : bool = True,
                               starBold : bool = False,
                               sandbox: bool = False,
                               prettyAlign : int = 2 ) : inlineContext
{
  val isTex2  = match(metadata["tex2"]) {
                  Just(value) -> value.toLower == "true"  
                  _ -> False
                }

  fun pickx(f,g,h) {
    match(fmt) {
      FmtTex  -> if (isTex2) then h else g
      FmtHtml -> f
    }                
  }
  InlineContext( inlineGrammar(fmt,bench), dict(), dict(), dict(), 
                 emptyRules,
                 metadata, mathinfos, embedinfos,
                 citestyle, sanitize, bench, verbose, mathStatic, highlight, starBold, sandbox, prettyAlign,
                 pickx(fmtHtmlCmd,fmtTexCmd,fmtLatexCmd), 
                 pickx(fmtHtmlEscape,fmtTexEscape,fmtLatexEscape), 
                 pickx(fmtHtmlLink,fmtTexLink,fmtLatexLink), 
                 pickx(fmtHtmlFootnote,fmtTexFootnote,fmtLatexFootnote),
                 pickx(fmtHtmlTable,fmtTexTable,fmtLatexTable),
                 pickx(fmtHtmlEnv,fmtTexEnv,fmtLatexEnv),
                 pickx(fmtHtmlCodePlain,fmtTexCodePlain,fmtLatexCodePlain),
                 //pickx(fmtHtmlCodeHilite,fmtTexCodeHilite,fmtLatexCodeHilite),
                 pickx(fmtHtmlCodeToken,fmtTexCodeToken,fmtLatexCodeToken),
                 pickx(fmtHtmlLineInfo, fmtTexLineInfo, fmtLatexLineInfo),
                 pickx(fmtHtmlCodeTable, fmtTexCodeTable, fmtLatexCodeTable),
                 pickx(if (isTex2) then fmtLatexMathCmd else fmtTexCmd,fmtTexCmd,fmtLatexMathCmd), // math cmd
                 pickx(if (isTex2) then fmtLatexMathEnv else fmtTexEnv,fmtTexEnv,fmtLatexMathEnv), // math env
                 fmt 
               )
}
